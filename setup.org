#+TITLE: Claude Code Block Tangler
#+AUTHOR: User
#+PROPERTY: header-args :mkdirp yes
#+OPTIONS: toc:2

* Claude Code Block Tangler

This org file helps you extract and save code blocks from Claude's markdown responses.

** Usage Instructions

1. Copy code blocks from Claude
2. Paste them into the appropriate section below
3. Run =org-babel-tangle= (C-c C-v t) to save all files at once

** Python Code

#+begin_src python :mkdirp yes :tangle "server/nlp_server.py"
#!/usr/bin/env python3
import asyncio
import websockets
import json
import spacy
import logging

# Set up logging
logging.basicConfig(
    format="%(asctime)s %(message)s",
    level=logging.INFO,
)

# Load spaCy model
nlp = spacy.load("en_core_web_sm")

# Store connected clients
connected = set()

async def register(websocket):
    """Register a new client connection."""
    connected.add(websocket)
    logging.info(f"Client connected. Total connections: {len(connected)}")

async def unregister(websocket):
    """Unregister a client connection."""
    connected.remove(websocket)
    logging.info(f"Client disconnected. Total connections: {len(connected)}")

async def process_text(websocket, message):
    """Process text with spaCy and return analysis."""
    try:
        data = json.loads(message)
        if "type" in data and data["type"] == "analyze":
            text = data.get("text", "")
            logging.info(f"Received text to analyze: '{text[:50]}...' ({len(text)} chars)")
            
            # Process with spaCy
            doc = nlp(text)
            
            # Extract entities
            entities = [
                {"text": ent.text, "label": ent.label_, "start": ent.start_char, "end": ent.end_char}
                for ent in doc.ents
            ]
            
            # Extract sentences
            sentences = [
                {"text": sent.text, "start": sent.start_char, "end": sent.end_char}
                for sent in doc.sents
            ]
            
            # Create response
            response = {
                "type": "analysis",
                "text": text,
                "entities": entities,
                "sentences": sentences,
                "tokens": len(doc)
            }
            
            await websocket.send(json.dumps(response))
    except json.JSONDecodeError:
        logging.error(f"Invalid JSON received: {message}")
    except Exception as e:
        logging.error(f"Error processing message: {e}")

async def handler(websocket):
    """Handle a connection and dispatch to the appropriate functions."""
    await register(websocket)
    try:
        async for message in websocket:
            await process_text(websocket, message)
    except websockets.exceptions.ConnectionClosed:
        pass
    finally:
        await unregister(websocket)

async def main():
    """Start the websocket server."""
    port = 8765
    host = "localhost"
    
    logging.info(f"Starting NLP websocket server on {host}:{port}")
    async with websockets.serve(handler, host, port):
        await asyncio.Future()  # Run forever

if __name__ == "__main__":
    asyncio.run(main())
#+end_src

** Emacs Lisp Code

#+begin_src emacs-lisp :mkdirp yes :tangle "elisp/spacy-mode.el"
;;; spacy-mode.el --- Process text with spaCy via websocket

;;; Commentary:
;; This mode connects to a spaCy-powered websocket server and sends
;; text for NLP analysis.

;;; Code:
(require 'websocket)
(require 'json)

(defgroup spacy nil
  "Process text with spaCy."
  :group 'text)

(defcustom spacy-server-url "ws://localhost:8765"
  "URL for the spaCy websocket server."
  :type 'string
  :group 'spacy)

(defvar spacy-websocket nil
  "Websocket connection to the server.")

(defvar spacy-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-c C-a") 'spacy-analyze-paragraph)
    (define-key map (kbd "C-c C-r") 'spacy-analyze-region)
    map)
  "Keymap for spaCy mode.")

(defun spacy-connect ()
  "Connect to the spaCy websocket server."
  (interactive)
  (when (and spacy-websocket 
             (websocket-openp spacy-websocket))
    (websocket-close spacy-websocket))
  
  (setq spacy-websocket
        (websocket-open
         spacy-server-url
         :on-open (lambda (ws) 
                    (message "Connected to spaCy server"))
         :on-message (lambda (ws frame)
                       (let* ((json-object-type 'plist)
                              (json-array-type 'list)
                              (data (json-read-from-string 
                                     (websocket-frame-text frame))))
                         (when (equal (plist-get data :type) "analysis")
                           (spacy-display-analysis data))))
         :on-close (lambda (ws) 
                     (message "Disconnected from spaCy server"))
         :on-error (lambda (ws type err) 
                     (message "Error: %s" err))))
  (message "Attempting to connect to %s..." spacy-server-url))

(defun spacy-disconnect ()
  "Disconnect from the spaCy websocket server."
  (interactive)
  (when (and spacy-websocket 
             (websocket-openp spacy-websocket))
    (websocket-close spacy-websocket)
    (setq spacy-websocket nil)
    (message "Disconnected from spaCy server")))

(defun spacy-analyze-text (text)
  "Send TEXT to the spaCy server for analysis."
  (if (and spacy-websocket 
           (websocket-openp spacy-websocket))
      (progn
        (message "Sending text for analysis (%d chars)..." (length text))
        (websocket-send-text 
         spacy-websocket
         (json-encode `(("type" . "analyze")
                        ("text" . ,text)))))
    (message "Not connected to server. Use M-x spacy-connect first")))

(defun spacy-analyze-paragraph ()
  "Send the current paragraph to the spaCy server."
  (interactive)
  (let ((para (thing-at-point 'paragraph t)))
    (if para
        (spacy-analyze-text para)
      (message "No paragraph at point"))))

(defun spacy-analyze-region (start end)
  "Send the region from START to END to the spaCy server."
  (interactive "r")
  (let ((text (buffer-substring-no-properties start end)))
    (spacy-analyze-text text)))

(defun spacy-display-analysis (data)
  "Display the spaCy analysis DATA in a buffer."
  (let ((buf (get-buffer-create "*spaCy Analysis*")))
    (with-current-buffer buf
      (let ((inhibit-read-only t))
        (erase-buffer)
        (insert "# spaCy Analysis Results\n\n")
        (insert (format "Analyzed %d tokens\n\n" (plist-get data :tokens)))
        
        ;; Display entities
        (let ((entities (plist-get data :entities)))
          (insert (format "## Named Entities (%d found)\n\n" (length entities)))
          (if entities
              (dolist (ent entities)
                (insert (format "- %s (%s)\n" 
                                (plist-get ent :text)
                                (plist-get ent :label))))
            (insert "No entities found\n")))
        
        ;; Display sentences
        (let ((sentences (plist-get data :sentences)))
          (insert (format "\n## Sentences (%d found)\n\n" (length sentences)))
          (if sentences
              (dolist (sent sentences)
                (insert (format "- %s\n" (plist-get sent :text))))
            (insert "No sentences found\n")))
        
        (goto-char (point-min))
        (markdown-mode)))
    
    ;; Display the buffer
    (display-buffer buf)))

;;;###autoload
(define-minor-mode spacy-mode
  "Toggle spaCy mode.
Interactively with no argument, this command toggles the mode.
A positive prefix argument enables the mode, any other prefix
argument disables it. From Lisp, argument omitted or nil enables
the mode, `toggle' toggles the state.

When spaCy mode is enabled, you can send text to a spaCy server
for NLP analysis."
  :init-value nil
  :lighter " spaCy"
  :keymap spacy-mode-map
  :global nil
  :group 'spacy
  
  (if spacy-mode
      (spacy-connect)
    (spacy-disconnect)))

(provide 'spacy-mode)
;;; spacy-mode.el ends here
#+end_src

** TRAMP-aware mkdirp Implementation

#+begin_src emacs-lisp :mkdirp yes :tangle "elisp/tramp-mkdirp.el"
(defun tramp-mkdirp (directory)
  "Create DIRECTORY and its parents recursively, working with both local and remote paths.
Works with TRAMP remote paths like /ssh:user@host:/path/to/dir"
  (interactive "DDirectory: ")
  (let ((dir (expand-file-name directory)))
    (unless (file-exists-p dir)
      (make-directory dir t))
    (message "Created directory: %s" dir)))

;; Integration with org-babel tangle
(defun org-babel-mkdirp-tangled-file ()
  "Make parent directories for all tangled files in the current buffer."
  (interactive)
  (org-babel-map-src-blocks nil
    (let* ((info (org-babel-get-src-block-info 'light))
           (tangle-file (cdr (assq :mkdirp yes :tangle (nth 2 info)))))
      (when (and tangle-file 
                (not (equal tangle-file "no"))
                (not (equal tangle-file "yes")))
        (let ((dir (file-name-directory (expand-file-name tangle-file))))
          (when dir (tramp-mkdirp dir)))))))

;; Add to org-babel tangle hook
(with-eval-after-load 'ob-tangle
  (add-hook 'org-babel-pre-tangle-hook 'org-babel-mkdirp-tangled-file))

(provide 'tramp-mkdirp)
#+end_src

** Shell Scripts

#+begin_src sh :mkdirp yes :tangle "setup.sh" :shebang "#!/bin/bash"
#!/bin/bash

# Setup script for para-spacy-lisp

# Create virtual environment
echo "Creating Python virtual environment..."
python3 -m venv venv
source venv/bin/activate

# Install required packages
echo "Installing required Python packages..."
pip install websockets spacy
python -m spacy download en_core_web_sm

echo "Setup complete!"
echo "To start the server:"
echo "  source venv/bin/activate"
echo "  python server/nlp_server.py"
#+end_src

#+begin_src sh :mkdirp yes :tangle "run_server.sh" :shebang "#!/bin/bash"
#!/bin/bash

# Activate virtual environment
source venv/bin/activate

# Start NLP server
python server/nlp_server.py
#+end_src

** Mermaid Diagrams

#+begin_src mermaid :file "architecture.png"
flowchart LR
    emacs["Emacs\n(with spacy-mode)"] <-->|"WebSocket\n(ws://localhost:8765)"| server["Python spaCy Server"]
    
    subgraph "Emacs Editor"
        buffer[Text Buffer] --> paragraph[Paragraph or Region]
        paragraph --> analyze["C-c C-a or C-c C-r\n(analyze text)"]
    end
    
    subgraph "Server Processing"
        receive[Receive Text] --> nlp[spaCy Processing]
        nlp --> respond[Send Analysis Result]
    end
    
    analyze --> emacs
    receive --> server
    respond --> emacs
#+end_src

** README file

#+begin_src markdown :mkdirp yes :tangle "README.md"
# para-spacy-lisp

A bridge between Emacs and spaCy NLP processing via WebSockets.

## Overview

This project provides an Emacs minor mode that connects to a Python spaCy server via WebSockets to analyze text. It allows sending paragraphs or regions of text directly from Emacs to spaCy for natural language processing.

## Features

- Send paragraphs or regions from Emacs to spaCy for analysis
- View named entities, sentences, and other NLP results
- Simple WebSocket communication between Emacs and Python
- Easy to extend with additional NLP capabilities

## Installation

1. Clone this repository:
   ```
   git clone https://github.com/yourusername/para-spacy-lisp.git
   cd para-spacy-lisp
   ```

2. Set up the Python environment:
   ```
   ./setup.sh
   ```

3. Add the Emacs Lisp files to your load path:
   ```elisp
   (add-to-list 'load-path "~/path/to/para-spacy-lisp/elisp")
   (require 'spacy-mode)
   ```

## Usage

1. Start the spaCy server:
   ```
   ./run_server.sh
   ```

2. In Emacs, activate the spaCy mode:
   ```
   M-x spacy-mode
   ```

3. Analyze text:
   - `C-c C-a` - Analyze the current paragraph
   - `C-c C-r` - Analyze the selected region

4. View the results in the `*spaCy Analysis*` buffer

## Architecture

The system consists of two main components:

1. **Python spaCy Server** - A WebSocket server that receives text and processes it with spaCy
2. **Emacs spaCy Mode** - A minor mode that connects to the server and provides commands for text analysis

The communication happens over WebSockets, with JSON messages containing the text to analyze and the analysis results.

## License

MIT
#+end_src

** Add your own code blocks here

You can add more code blocks from Claude conversations by copying them here and assigning appropriate tangle targets.

#+begin_src python :mkdirp yes :tangle "examples/example1.py"
# Add your own code block here
print("This is an example file")
#+end_src

* Tangling Instructions

To tangle all these files at once:

1. Save this org file
2. Open it in Emacs
3. Press C-c C-v t (or M-x org-babel-tangle)
4. All files will be created in their specified locations

You can also tangle individual code blocks by placing your cursor inside the block and pressing C-c C-v t.
